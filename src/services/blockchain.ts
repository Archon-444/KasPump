import { ethers } from 'ethers';
import { KasPumpToken } from '@/types';
import { getTokenFactoryAddress, getChainName } from '@/config/contracts';

// Note: We import types that will be generated by TypeChain
// If this import fails in your IDE, run 'npm run typechain' or 'npx hardhat typechain'
import { 
  TokenFactory__factory, 
  BondingCurveAMM__factory,
  TokenFactory,
  BondingCurveAMM
} from 'typechain-types';

export class BlockchainService {
  private provider: ethers.Provider;
  private chainId: number;
  private factoryContract: TokenFactory | null = null;

  constructor(rpcUrl: string, chainId: number) {
    this.provider = new ethers.JsonRpcProvider(rpcUrl);
    this.chainId = chainId;
  }

  private getFactoryContract(): TokenFactory {
    if (this.factoryContract) return this.factoryContract;

    const factoryAddress = getTokenFactoryAddress(this.chainId);
    if (!factoryAddress) {
      throw new Error(`TokenFactory not deployed on chain ${this.chainId} (${getChainName(this.chainId)})`);
    }

    // Connect using TypeChain factory
    this.factoryContract = TokenFactory__factory.connect(factoryAddress, this.provider);
    return this.factoryContract;
  }

  // Get AMM contract for a specific token
  private async getAMMContract(tokenAddress: string): Promise<BondingCurveAMM> {
    const factory = this.getFactoryContract();
    
    // TypeSafe call to factory
    const ammAddress = await factory.getTokenAMM(tokenAddress);
    
    if (!ammAddress || ammAddress === ethers.ZeroAddress) {
      throw new Error(`AMM not found for token ${tokenAddress}`);
    }

    // Connect using TypeChain factory
    return BondingCurveAMM__factory.connect(ammAddress, this.provider);
  }

  /**
   * Get all tokens created on the platform
   * @returns Array of token addresses
   */
  async getAllTokens(): Promise<string[]> {
    try {
      const factory = this.getFactoryContract();
      // TypeSafe call
      return await factory.getAllTokens();
    } catch (error) {
      console.error('Error fetching all tokens:', error);
      return [];
    }
  }

  /**
   * Get detailed information for a token
   * @param tokenAddress The address of the token
   */
  async getTokenDetails(tokenAddress: string): Promise<Partial<KasPumpToken> | null> {
    try {
      const factory = this.getFactoryContract();
      
      // Check if it is a valid token - TypeSafe
      const isValid = await factory.isKasPumpToken(tokenAddress);
      if (!isValid) return null;

      const ammContract = await this.getAMMContract(tokenAddress);

      // Parallel data fetching
      // 1. Get Token Config from Factory (struct)
      // 2. Get Trading Info from AMM (tuple)
      const [config, tradingInfo] = await Promise.all([
        factory.getTokenConfig(tokenAddress),
        ammContract.getTradingInfo()
      ]);

      // Destructure trading info (based on contract return values)
      // [virtualTokenReserves, currentPrice, totalVolume, graduationThreshold, isGraduated]
      const currentSupply = parseFloat(ethers.formatEther(tradingInfo[0]));
      const currentPrice = parseFloat(ethers.formatEther(tradingInfo[1]));
      const totalVolume = parseFloat(ethers.formatEther(tradingInfo[2]));
      const graduationThreshold = parseFloat(ethers.formatEther(tradingInfo[3]));
      const isGraduated = tradingInfo[4];

      // Calculate graduation progress %
      // This logic depends on your bonding curve math. 
      // Assuming progress is based on accumulated volume or current supply vs threshold
      // For a simple linear curve, let's say progress is (currentSupply / maxSupply) * 100 or similar.
      // Or if the contract emits a specific "progress" value, use that.
      // Here we approximate based on price or volume if needed, 
      // but let's assume 'graduationThreshold' is a volume target for simplicity, 
      // or we can just return 0 if not easily calculable without more data.
      // A better approach is to read the 'graduationProgress' if your contract exposes it, 
      // or calculate: (fundsRaised / fundingGoal) * 100.
      
      // Placeholder progress calculation:
      const progress = isGraduated ? 100 : Math.min(100, (totalVolume / 50000) * 100); // Example divisor

      return {
        address: tokenAddress,
        name: config.name,
        symbol: config.symbol,
        description: config.description,
        image: config.imageUrl,
        curveType: config.curveType === 0n ? 'linear' : 'exponential', // 0 = Linear, 1 = Exponential
        currentSupply,
        price: currentPrice,
        volume24h: totalVolume, // Note: this is total volume, not 24h. Indexer needed for 24h.
        isGraduated,
        bondingCurveProgress: progress,
        ammAddress: await ammContract.getAddress(),
        createdAt: new Date() // Block timestamp would require another call
      };

    } catch (error) {
      console.error(`Error fetching token details for ${tokenAddress}:`, error);
      return null;
    }
  }
}
